https://youtube.com/playlist?list=PLDyJYA6aTY1lPWXBPk0gw6gR8fEtPDGKa&si=X2WtHAICSZClTVBY
### Ввод и вывод данных. Строки. Переменные

**sep="n"** - разделитель (по дефолту это пробел если мы его не прописываем, если указать **""** то разделителя вовсе не будет, в общем все что мы укажем вместо n, то и будет разделять наш принт)
**end='m'** - чем заканчивается наш принт (по дефолту это \n)

https://youtu.be/yuyq2BrHMJE?si=bAl6FxMmvvHXmYE8
![[Pasted image 20250716163751.png]]
**`a, b, c = map (int, input().split())`** - для того чтобы можно было присвоить значения переменным a, b и с введя их через пробел: 123 1 431 

#### **f-строки**
https://youtu.be/mAAINwpm0Ik?si=mGfCK99-3m34m-kJ #3:47
```
name = "Alex"
age = 17
print(f"name: {name}, age: {age}")
```

Внутри { } можно помещать переменную, числа различных типов, функции

Если нам необходимо вывести значение переменной и название самой переменной (так как сама переменная является пояснением к ее значению, например: name = Masha), то 
```
name =  "Masha"
print(f'{name=}')
```
Получим: name = "Masha"

Точно так же можно делать и с функциями

Если после запятой нам нужно вывести определенное количество значений:

```
value = 21.5678

print(f'{value:.2f}')
```
Получим: 21.57

https://youtu.be/lmGjrmCj1nA?si=dGxYnw3-ZkYPTeDS
**rstrip** - удаляет все пробелы справа (**lstrip** - соответственно слева);

```
str1 = 'Hello Mir'
str2 = '   Hello Mir'
str3 = 'Hello Mir    '
print(str1.rstrip())
```
**strip** - убрать лишние пробелы с начала и конца строки;
**/n** — **переход** **на** новую **строку**; 
Мы имеем доступ к тем же функциям, что и при работе со списками, строка это по сути тот же список, но в нем каждый символ это отдельный элемент, то есть в строке "Привет я Вета", каждый элемент П р и в е т  я  В е т а (включая пробелы) это отдельный элемент к которому можно обратиться 
**upper()** - приводит строку в верхний регистр
**isupper()** - проверяет находиться ли строка в верхнем регистре 
**lower()** - приводит строку к нижнему регистру 
**islower()** - проверяет находиться ли вся строка в нижнем регистре
**capitalize()** - приводит первый символ строки  верхний регистр, а все остальные в нижний
**len() -** подсчитывает количество элементов в разных типах данных
```
for _ in words:  
    _ = _.capitalize()  
print(words)  
  
for _ in range(len(words)):  
    words[_] = words[_].capitalize()  
print(words)
```
В данном случае будет работать корректно второй цикл, так как в первом мы изменяем лишь копию элемента из списка и далее никуда ее не сохраняем и просто выводим наш старый не измененный список, поэтому во избежание данного случая нам необходимо брать сам элемент ''оригинал'' и использовать на него функцию .capitalize( )
**find(n)** - вместо n мы передаем символ индекс которого мы хотим получить (нам выведется индекс)
**split(n)** - из строки получаем список (вместо n тот знак до которого будет считаться элемент то есть если n = 'V', то:
```
str = jefgVjfnhVonVij
print(str.split('V'))
```
 мы получим: ['jefg', 'jfnh', 'on', 'ij']

**Это срез** - если мы хотим вывести диапазон элементов, то мы указываем это в формате [n:m], нам будут выведены элементы с n до m, если прописать [n:], то с элемента n до конца, тут также можно указать шаг [n:m:k],  k - это шаг вывода, можно прописать [::], тогда там установятся значения по умолчанию
```
word = 'Football'  
  
print(word[4:-1])
```

https://youtu.be/K8yYltTnSgQ?si=NsyiySl9BiJt8aef
**isdigit()**  - проверяет состоит ли строка из цифр, если да, возвращает значение True, нет - False;

**del** - удаление переменной
#### Условные операторы 

**if** - обязательно в самом верху
**elif** - можем проверить некое дополнительное условие, если условие оказывается верным, то else не срабатывает (данных операторов может быть сколько угодно)
**else** - можно не использовать (всегда находиться в конце)
**Тернарный оператор** - это тоже самое что конструкция if-else, но он записывается в одну строку
```
number = 5 if data == "Five" else 0
```
вместо 
if data == 'Five':
	number = 5
else: 
	number =0
https://youtu.be/6DOd09kWMlo?si=Sz_UogTJtEKb-9zf
**and**  - операция выполниться, если оба условия будут True (оператор and прекращает проверку если первый операнд оказался ложным)
**or** - если одно условие True, то операция выполниться

первым выполняется оператор not, and, а потом or, но порядок вычисления можно поменять скобками

**not** - превращает лож в истину, а истину в лож 
```
isHappy = True

if not isHappy: # Условие будет выполнено если isHappy != True 
```


### Циклы и операторы в них (for, while)
#### For - цикл
**range** - перебирает числа
**Любая строка это список из множества символов**
```
`for i in range(6):`
	`print(i)`
```
Получим:  0    1 2 3 4 5 
         (0) (1) ...     (5)

```
`for i in range(1, 6):`
	`print(i)`
```
Получим: 1 2 3 4 5 

```
`for i in range(1, 6, 2):`
	`print(i)`
```
Получим: 1 3 5 (потому что третья переменная в range это шаг)

```
word = 'Hello'
for i in word:
	print(i)
```
Получим: 
H
e
l
l
o

```
count = 0
word = 'Hello'
for i in word:
	if i == "l":
		count ++
		print("I fount a part of love!")
print("Count: ", count)
```


#### While
```
i = 7
while i < 13:
	print(i)
	i++
```
В цикле While пока условие будет истинным программа будет выполняться ```while True```  бесконечный цикл 



#### Операторы 
https://youtu.be/z_2AdMZW53I?si=pHCbsEnP2yxsJPL5
**break** - преждевременный выход из цикла 
```
for i in range(1, 6):
	if i == 4:
		break
```

**continue** - преждевременно переходит к новой итерации 
**pass** - глушит то что мы хотели выйти из цикла (несмотряна условия мы продолжаем)

### Списки [list] 
```
nums = [] # пустой список 
print(nums)
```

Вывод:
[]

```
nums = [3, 5, 34, 324, 2]
print(nums)
```

Вывод:
[3, 5, 34, 324, 2]

```
nums = [3, 5, True, 'Hello', 434, 2] # Можно хранить разные типы данных 
print(nums)
```

Вывод: [3, 5, True, 'Hello', 434, 2] 

```
nums = [3, 5, True, 'Hello', 434, 2, [3, 5]] # Можно хранить разные типы данных 

print(nums[0], nums[3])
print(nums[-1][-1])
```

Вывод:
3 Hello
5


```
numbers = [5, 3, 8]
numbers[3] = 193
```

Вывод: Error (элемента с таким индексом не существует)

**index()** - присваивает переменной значение индекса определенного элемента:

```
numbers = [5, 3, 8]
inx = numbers.index(3)
```

**append()** - добавляет элемент в конец списка;

**insert(n, m)** - устанавливает значение на определенное место, где n -  индекс по которому будет установлен элемент, сам элемент !!! при этом элемент, который находился по данному индексу не удаляется, все элементы сдвигаются на +1 к индексу;

**extend([12, 4, 'Help'])** - принимает в качестве значения еще один список. и добавляет его в конец нашего списка;

Для того чтобы добавить список не в конец списка, а на определенную позицию мы указываем промежуток (срез) куда хотим его вставить, то есть если на 3 позицию ничего не удаляя, т мы прописываем 3:3, если вместо 3 позиции, то пишем 3:4, если вместо 3 и 4, то прописываем 3:5: 
```
nums = [1, 2, 3, 7]  
nums1 = [1, 2, 3, 3, 43, 7]  
new = [4, 5, 6]  
  
n = nums.index(3) + 1 # => n = 3
nums[n:n] = new # Значит на 3 позицию будет поставлено new
```
```
lis = [34, 835, 'Hello', True, 4]  
print(lis[0:-1:2])
```

**sort()** - cортирует список;

**reverse** - переворачивает список;

**pop(n)** - удаление последнего элемента из списка, можем добавить индекс элемента, который мы хотим удалить (n);

**remove**() - удаляет элемент с определенным (указанным) значением (если элементов с таким значением несколько, то удаляет самый первый);

**clear()** - очищает весь список;

**count(n)** - подсчитывает количество элементов со значением n;

**len(list)** - подсчитывает длину всего списка list;

Перебор списка лучше всего делать через цикл **for**

```
numbers = [5, 3, 8]
numbers.append(True)
numbers.append(92)
numbers.insert(1, True)
numbers.extend([12, 4, 'Help'])
numbers.sort

print(numbers)

for el in numbers:
		print(el)
```

https://youtu.be/_zBTBr6XdZo?si=eSEAn6xJU7QhjFdj
**Генератор списка** 
Шаблон: [выражение for val in коллекция]
```
a = [i for i in range(7)]
print(a)
```

https://youtu.be/M5DB3Yun8gU?si=oiKAMdVRqz7eRpLE
**split(n)** - из строки получаем список (вместо n тот знак до которого будет считаться элемент то есть если строка будет 
```
str = jefgVjfnhVonVij
print(str.split('V'))
```
 мы получим: ['jefg', 'jfnh', 'on', 'ij']

**'n'.join(listick)** - из списка получаем строку (n это то чем элементы будут разделены в строке, а listick это список из которого мы делаем строку
```
line = 'У меня получиться: поступить на курсы, пройти курсы, попасть на стажировку, работать дистанционно, жить в вечном лете'  
iCan, goals = line.split(':')  
print("Я смогу:", goals)
```

```
line = 'У меня получиться: поступить на курсы, пройти курсы, попасть на стажировку, работать дистанционно, жить в вечном лете'  
print ('#'.join(line.split(',')))    
```
ЭТО МОЖНО ДЕЛАТЬ ТОЛЬКО С ФОРМАТОМ SRT ПОЭТОМУ ПЕРЕД ТЕМ КАК ИСПОЛЬЗОВАТЬ JOIN() НУЖНО ПРЕОБРАЗОВАТЬ ВСЕ В СТРОЧНЫЙ РЕЖИМ:

```
n = [12, 23, 3, 2]  
print(' '.join([str(i) for i in n]))
```
### Картежи (tuple)
**Картеж** - по сути ноже самое, что и список, но это некая константа, в которую мы добавляем элементы и изменить уже картеж нельзя, и второе отличие - картеж занимает меньше памяти чем список. Картеж объявляется как:
```
data = (1, 2, 3, True, 34.4, 'Hello')
```
**count(n)** - посчитать сколько в картеже элементов n 
**len(data)** - подсчитает количество элементов в списке

```
data = 1, 2, 3, True, 34.4, 'Hello' # Это тоже картеж
```
НО 
```
data = (6) # Это не картеж
```
НО
```
data = (6, )
``` 
ИЛИ 
```
data = 6, 
```
ЭТО КАРТЕЖИ

```
nums = [1, 2, 3, 4, 5]  
new_data = tuple(nums)
```
**tuple(nums)** - преобразовывает список в картеж 
```
word = tuple('Hello Mir')
```
Можно и строку тоже преобразовать в картеж, но он будет преобразован по одному элементу (так как строка это тот же список, но в котором каждый символ это есть элемент). Получим: 
('H', 'e', 'l', 'l', 'o', ' ', 'M', 'i', 'r')

### Словари {dict} 

```
person = {
	'user_1': {
		 'name': 'Bob',
		 'age': 23,
		 'adress': ('г. Москва', 'ул. Какая-то'),
		 'grades': {
			 'math': 5,
			 'phythics': 4
			 }
	},
	'user_2': {
		'name': 'Joy'}
print (person['user_1'][adress][1])
```


Получим: ул. Какая-то
```
country = {'code': 'BY', 'name': 'Belarus, 'population': 9002002}
print(country['name'])
for key in country:
	print(key)
```

Получим только ключи:
Belarus
code
name
population

Если хотим получить не только ключи, но еще и значения, нужно прописать: 

```
country = {'code': 'BY', 'name': 'Belarus, 'population': 9002002}
print(country.items())
```
Получим:
dict_items([('code', 'BY'), ('name', 'Belarus'), ('population', 9002002)])

```
country = {'code': 'BY', 'name': 'Belarus', 'population': 9002002}  
for key, value in country.items():  
    print(key, value)
```
Получим:
code BY
name Belarus
population 9002002

ИЛИ

```
country = dict(code = 'BY', name = 'Belarus')
print (country['name'])```
```
Получим: Belarus

```
country = {'code': 'BY', 'name': 'Belarus, 'population': 9002002}
for key in country:
	print(key)
```

Получим (то есть вместо 0 1 2 у нас будут выводиться ключи)
code
name
population

##### Вместо 

```
print (country[4])
```

Можно написать:
```
print(country.get('name'))
```

**country.clear()** - очищает наш словарь от всех элементов
**country.pop('name')** - удалит элемент у которого ключ name
**country.popitem()** - удалит последний элемент 
**country.values()** - получим все значения 
**country.items()** - получим список из картежей в которых элементы это ключ и значение соответственно
**country['code'] = 'RU'** - обновление значения 
**country.update({})** - обновление значения 
### Множества (set frouzen)

**Множества** - это те же самые списки только тут все элементы лежат  в рандомном порядке и тут не может быть повторяющихся элементов
Можно списки преобразовывать в множества и тем самым избавиться от повторяющихся элементов или если необходимо зашафлить значения (то бишь перемешать их)
**Замороженное множество** - это тоже самое множество, но со свойствами картежей

```
data = set('hello') # Это мы создали множество
```
```
new_data = frozenset([5, 75, 345, 312, 5,  5, True ]) # А это замороженное множество
```

Обычно множество создают так: 

```
data = {5, 75, 345, 312, 5 }
```
**Правило:** В множествах мы не можем вызвать какой-то один определенный элемент (они грубо говоря просто лежат в коробке в рандомном порядке и если мы от туда уже достали один элемент, то второй точно такой же мы доставать не будем)

**data.add()** - добавление нового элемента
**data.update()** - это если нам необходимо добавить несколько элементов
**data.remove(n)** - удаление n элемента из множества (если n элементов в множестве несколько, то удаляться все n элементы)
**set(data)** - удаляет ВСЕ повторяющиеся элементы из множества
**data.pop()** - удаление первого элемента из множества (как это происходит: множество перемешивается, достаются значения в соответствии с правилом, удаляется первый элемент):
```
{'h', 'o', 'e', 'l'}
{'o', 'e', 'l'}
```
**data.clear()** - очистка множества

### Функции (def, lambda)
**Функции** - это что-то типо подпрограммы, которая будет иметь свое имя, а при необходимости нам не предеться прописывать весь код функции, а лишь вызывать ее с помощью ее вызова
```
def test_func(n):  # объявление функции c параметром n например n (он будет виден исключительно в функции)
    pass # ничего не происходит
test_func() # Вызов функции
```
```
return n # возвращает значение чтобы далее с ней можно было взаимодействовать 
```
Лямбда функции (анонимные функции) - это короткий способ записать маленькую функцию (разница идет в форме записи)
```
func = lambda x, y: x + y
```
Вместо:
```
def func(x, y)
	return x + y
```
### Файлы
открыть - работа с файлом - закрыть (иначе утечка памяти)
file = open("text.txt") # Открывает файл text.txt (если его не существует, то создаст и откроет)

![[Pasted image 20250821152128.png]]
### Обработчики исключений try - exept

Если ввести тут число, то все обработается корректно (это мы прописываем в **try**), а если строку, то будет выдана ошибка, мы смотрим как эта ошибка называется в нашем случае ValueError, далее описываем в **except**, как она будет обрабатываться 
**finally** - это блок, который сработает в любом случае после try или после exept (то есть если вдруг мы по итогу несколько раз выполним except, то сколько и finally вызовется соответствующее количество раз)
**else** - срабатывает если except не сработал


```
v = 0
while v == 0:
	try:
		v = int(input("Введите число v: "))
		v += 5
		print(f"Ваше число {v}")
		x = 5 / 0
	except ValueError:
		print("Введите лучше число!")
	except ZeroDivisionError
		print("Деление на нооооль!")
	
```

### Менеджер With .... as для работы с файлами

```
# try:  
#     file = open('text.txt', 'r')  # считывает данные из файла (если его не существует, то выдаст ошибку)  
#     # Ошибка!!!  
#  
#     #Это не выполнелось!  
#     file.read()  
#     file.close()  
# except FileNotFoundError:  
#     print('Файл не найден')  
  
try:  
    with open('text.txt', 'r', encoding='utf-8') as file:  
        print(file.read())  
except FileNotFoundError:  
    print("Файл не найден")
```
Файл был открыт его необходимо закрыть если мы его попытаемся закрыть в блоке finally то не получиться так как file виден в блоке try
Поэтому мы будем использовать менеджер with-as
**with open('text.txt', 'r', encoding='utf-8') as file**
в момент открытия файла мы говорим что этот же файл и будет сам закрываться по завершению его работы поэтому file.close() прописывать не надо